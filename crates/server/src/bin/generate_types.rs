use std::{collections::HashMap, env, fs, path::Path};

use schemars::{JsonSchema, Schema, SchemaGenerator, generate::SchemaSettings};
use ts_rs::TS;

fn generate_types_content() -> String {
    // 4. Friendly banner
    const HEADER: &str = "// This file was generated by `crates/core/src/bin/generate_types.rs`.\n
// Do not edit this file manually.\n
// If you are an AI, and you absolutely have to edit this file, please confirm with the user first.";

    let decls: Vec<String> = vec![
        services::services::filesystem::DirectoryEntry::decl(),
        services::services::filesystem::DirectoryListResponse::decl(),
        db::models::project::Project::decl(),
        db::models::project::CreateProject::decl(),
        db::models::project::UpdateProject::decl(),
        db::models::project::SearchResult::decl(),
        db::models::project::SearchMatchType::decl(),
        executors::actions::ExecutorAction::decl(),
        executors::mcp_config::McpConfig::decl(),
        executors::actions::ExecutorActionType::decl(),
        executors::actions::script::ScriptContext::decl(),
        executors::actions::script::ScriptRequest::decl(),
        executors::actions::script::ScriptRequestLanguage::decl(),
        executors::executors::BaseCodingAgent::decl(),
        executors::executors::CodingAgent::decl(),
        db::models::task_template::TaskTemplate::decl(),
        db::models::task_template::CreateTaskTemplate::decl(),
        db::models::task_template::UpdateTaskTemplate::decl(),
        db::models::task::TaskStatus::decl(),
        db::models::task::Task::decl(),
        db::models::task::TaskWithAttemptStatus::decl(),
        db::models::task::TaskRelationships::decl(),
        db::models::task::CreateTask::decl(),
        db::models::task::UpdateTask::decl(),
        db::models::image::Image::decl(),
        db::models::image::CreateImage::decl(),
        utils::response::ApiResponse::<()>::decl(),
        server::routes::config::UserSystemInfo::decl(),
        server::routes::config::Environment::decl(),
        server::routes::config::McpServerQuery::decl(),
        server::routes::config::UpdateMcpServersBody::decl(),
        server::routes::config::GetMcpServerResponse::decl(),
        server::routes::task_attempts::CreateFollowUpAttempt::decl(),
        server::routes::task_attempts::FollowUpDraftResponse::decl(),
        server::routes::task_attempts::UpdateFollowUpDraftRequest::decl(),
        server::routes::task_attempts::ChangeTargetBranchRequest::decl(),
        server::routes::task_attempts::ChangeTargetBranchResponse::decl(),
        server::routes::tasks::CreateAndStartTaskRequest::decl(),
        server::routes::task_attempts::CreateGitHubPrRequest::decl(),
        server::routes::images::ImageResponse::decl(),
        services::services::github_service::GitHubServiceError::decl(),
        services::services::config::Config::decl(),
        services::services::config::NotificationConfig::decl(),
        services::services::config::ThemeMode::decl(),
        services::services::config::EditorConfig::decl(),
        services::services::config::EditorType::decl(),
        services::services::config::GitHubConfig::decl(),
        services::services::config::SoundFile::decl(),
        services::services::config::UiLanguage::decl(),
        services::services::auth::DeviceFlowStartResponse::decl(),
        server::routes::auth::DevicePollStatus::decl(),
        server::routes::auth::CheckTokenResponse::decl(),
        services::services::git::GitBranch::decl(),
        utils::diff::Diff::decl(),
        utils::diff::DiffChangeKind::decl(),
        services::services::github_service::RepositoryInfo::decl(),
        executors::command::CommandBuilder::decl(),
        executors::profile::ExecutorProfileId::decl(),
        executors::profile::ExecutorConfig::decl(),
        executors::executors::BaseAgentCapability::decl(),
        executors::executors::claude::ClaudeCode::decl(),
        executors::executors::gemini::Gemini::decl(),
        executors::executors::gemini::GeminiModel::decl(),
        executors::executors::amp::Amp::decl(),
        executors::executors::codex::Codex::decl(),
        executors::executors::codex::SandboxMode::decl(),
        executors::executors::codex::ReasoningEffort::decl(),
        executors::executors::codex::ReasoningSummary::decl(),
        executors::executors::cursor::Cursor::decl(),
        executors::executors::opencode::Opencode::decl(),
        executors::executors::qwen::QwenCode::decl(),
        executors::executors::AppendPrompt::decl(),
        executors::actions::coding_agent_initial::CodingAgentInitialRequest::decl(),
        executors::actions::coding_agent_follow_up::CodingAgentFollowUpRequest::decl(),
        server::routes::task_attempts::CreateTaskAttemptBody::decl(),
        server::routes::task_attempts::RebaseTaskAttemptRequest::decl(),
        server::routes::task_attempts::GitOperationError::decl(),
        server::routes::task_attempts::ReplaceProcessRequest::decl(),
        server::routes::task_attempts::CommitInfo::decl(),
        server::routes::task_attempts::BranchStatus::decl(),
        services::services::git::ConflictOp::decl(),
        db::models::task_attempt::TaskAttempt::decl(),
        db::models::execution_process::ExecutionProcess::decl(),
        db::models::execution_process::ExecutionProcessStatus::decl(),
        db::models::execution_process::ExecutionProcessRunReason::decl(),
        db::models::merge::Merge::decl(),
        db::models::merge::DirectMerge::decl(),
        db::models::merge::PrMerge::decl(),
        db::models::merge::MergeStatus::decl(),
        db::models::merge::PullRequestInfo::decl(),
        db::models::follow_up_draft::FollowUpDraft::decl(),
        executors::logs::CommandExitStatus::decl(),
        executors::logs::CommandRunResult::decl(),
        executors::logs::NormalizedEntry::decl(),
        executors::logs::NormalizedEntryType::decl(),
        executors::logs::FileChange::decl(),
        executors::logs::ActionType::decl(),
        executors::logs::TodoItem::decl(),
        executors::logs::ToolResult::decl(),
        executors::logs::ToolResultValueType::decl(),
        executors::logs::ToolStatus::decl(),
        executors::logs::utils::patch::PatchType::decl(),
        utils::approvals::ApprovalStatus::decl(),
        utils::approvals::CreateApprovalRequest::decl(),
        utils::approvals::ApprovalResponse::decl(),
        serde_json::Value::decl(),
    ];

    let body = decls
        .into_iter()
        .map(|d| {
            let trimmed = d.trim_start();
            if trimmed.starts_with("export") {
                d
            } else {
                format!("export {trimmed}")
            }
        })
        .collect::<Vec<_>>()
        .join("\n\n");

    format!("{HEADER}\n\n{body}")
}

fn generate_json_schema<T: JsonSchema>() -> Result<String, serde_json::Error> {
    // Draft-07, inline everything (no $defs)
    let mut settings = SchemaSettings::draft07();
    settings.inline_subschemas = true;

    let generator: SchemaGenerator = settings.into_generator();
    let schema: Schema = generator.into_root_schema_for::<T>();

    // Convert to JSON value to manipulate it
    let mut schema_value: serde_json::Value = serde_json::to_value(&schema)?;
    // Remove the title from root schema to prevent RJSF from creating an outer field container
    if let Some(obj) = schema_value.as_object_mut() {
        obj.remove("title");
    }
    let formatted = serde_json::to_string_pretty(&schema_value)?;
    Ok(formatted)
}

fn generate_schemas() -> Result<HashMap<&'static str, String>, serde_json::Error> {
    // // Generate schemas for all executor types
    println!("Generating JSON schemas…");
    let schemas: HashMap<&str, String> = HashMap::from([
        (
            "amp",
            generate_json_schema::<executors::executors::amp::Amp>()?,
        ),
        (
            "claude_code",
            generate_json_schema::<executors::executors::claude::ClaudeCode>()?,
        ),
        (
            "gemini",
            generate_json_schema::<executors::executors::gemini::Gemini>()?,
        ),
        (
            "codex",
            generate_json_schema::<executors::executors::codex::Codex>()?,
        ),
        (
            "cursor",
            generate_json_schema::<executors::executors::cursor::Cursor>()?,
        ),
        (
            "opencode",
            generate_json_schema::<executors::executors::opencode::Opencode>()?,
        ),
        (
            "qwen_code",
            generate_json_schema::<executors::executors::qwen::QwenCode>()?,
        ),
    ]);
    println!(
        "✅ JSON schemas generated. {} schemas created.",
        schemas.len()
    );
    Ok(schemas)
}

fn write_schemas(
    schemas_path: &Path,
    schemas: HashMap<&str, String>,
) -> Result<(), Box<dyn std::error::Error>> {
    fs::create_dir_all(schemas_path)?;

    for (name, content) in schemas {
        let schema_file = schemas_path.join(format!("{}.json", name));
        fs::write(&schema_file, content)?;
        println!("✅ Generated schema: {}", schema_file.display());
    }

    Ok(())
}

fn schemas_up_to_date(schemas_path: &Path, schemas: &HashMap<&str, String>) -> bool {
    for (name, expected_content) in schemas {
        let schema_file = schemas_path.join(format!("{}.json", name));
        let current_content = fs::read_to_string(&schema_file).unwrap_or_default();
        if &current_content != expected_content {
            eprintln!("❌ Schema shared/schemas/{}.json is not up to date.", name);
            return false;
        }
    }
    true
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let check_mode = args.iter().any(|arg| arg == "--check");

    let shared_path = Path::new("shared");

    println!("Generating TypeScript types…");

    let generated_types = generate_types_content();
    let schema_content = match generate_schemas() {
        Ok(s) => s,
        Err(e) => {
            eprintln!("❌ Failed to generate JSON schemas: {}", e);
            std::process::exit(1);
        }
    };

    let types_path = shared_path.join("types.ts");
    let schemas_path = shared_path.join("schemas");

    if check_mode {
        // Check TypeScript types
        let current = fs::read_to_string(&types_path).unwrap_or_default();
        let types_up_to_date = if current == generated_types {
            println!("✅ shared/types.ts is up to date.");
            true
        } else {
            eprintln!("❌ shared/types.ts is not up to date.");
            false
        };

        // Check JSON schemas
        let schemas_up_to_date = schemas_up_to_date(&schemas_path, &schema_content);

        // Exit with appropriate code
        if types_up_to_date && schemas_up_to_date {
            std::process::exit(0);
        } else {
            eprintln!("Please run 'npm run generate-types' and commit the changes.");
            std::process::exit(1);
        }
    } else {
        // Wipe existing shared
        fs::remove_dir_all(shared_path).ok();

        // Recreate folder
        fs::create_dir_all(shared_path).expect("cannot create shared");

        // Write the file as before
        fs::write(&types_path, generated_types).expect("unable to write types.ts");
        println!("✅ TypeScript types generated in shared/");

        write_schemas(&schemas_path, schema_content).expect("unable to write schemas");

        println!("✅ JSON schemas generated in shared/schemas/");
    }
}
